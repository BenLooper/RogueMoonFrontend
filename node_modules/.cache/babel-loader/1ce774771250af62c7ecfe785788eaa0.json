{"ast":null,"code":"export const initialState = {\n  //login\n  usernameInput: '',\n  passwordInput: '',\n  user: {},\n  ownedCards: [],\n  games: [],\n  //gameboard\n  gameOn: false,\n  drawHands: false,\n  gameCards: [],\n  enemyGameCards: [],\n  hand: [],\n  enemyHand: [],\n  userDiscard: [],\n  enemyDiscard: [],\n  enemyField: {\n    space: [],\n    ground: [],\n    foot: []\n  },\n  userField: {\n    space: [],\n    ground: [],\n    foot: []\n  },\n  //scores \n  userScore: 0,\n  enemyScore: 0,\n  //passing\n  userTurn: true,\n  userPass: false,\n  enemyPass: false,\n  //reactors \n  userReactors: 2,\n  enemyReactors: 2,\n  userVictory: null\n};\n\nconst rowScore = array => {\n  let score = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    score += array[i].strength;\n  }\n\n  return score;\n};\n\nconst newTotalScore = field => {\n  //we iterate through the field values (rows), and get the total of each rowScore\n  let total = Object.values(field).reduce((total, row) => total + rowScore(row), 0);\n  return total;\n};\n\nconst shuffle = array => {\n  var currentIndex = array.length,\n      temporaryValue,\n      randomIndex; // While there remain elements to shuffle...\n\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1; // And swap it with the current element.\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n};\n\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    case 'CHANGE_USERNAME_INPUT':\n      return { ...state,\n        usernameInput: action.value\n      };\n      break;\n\n    case 'CHANGE_PASSWORD_INPUT':\n      return { ...state,\n        passwordInput: action.value\n      };\n      break;\n\n    case 'SET_USER':\n      return { ...state,\n        user: action.user,\n        ownedCards: action.ownedCards,\n        games: action.games,\n        gameOn: false\n      };\n      break;\n\n    case 'SET_GAME_CARDS':\n      //TODO -> Gets sent a list of chosen cards to set as gameCards from the selection screen\n      let shuffledGameCards = shuffle(state.ownedCards);\n      let shuffledEnemyGameCards = shuffle(state.ownedCards);\n      return { ...state,\n        gameCards: shuffledGameCards,\n        enemyGameCards: shuffledEnemyGameCards,\n        gameOn: true,\n        drawHands: true\n      };\n      break;\n\n    case 'SET_HANDS':\n      //Separate from game cards because hand is drawn in the battlefield, not the selection screen\n      //TODO -> Hand is drawn from gameCards\n      let newGameCards = state.gameCards.filter(card => !action.hand.includes(card));\n      let newEnemyGameCards = state.EnemyGameCards.filter(card => !action.enemyHand.includes(card));\n      return { ...state,\n        hand: action.hand,\n        enemyHand: action.enemyHand,\n        drawHands: false\n      };\n      break;\n\n    case 'PLAY_CARD':\n      //Possible change --> send over something to indicate whether it's the enemy or user \n      let role = action.role; //Remove the card from hand\n\n      let updatedUserHand = state.hand.filter(card => card.id !== action.card.id); //Update the row, then update the field with that row \n\n      let updatedUserRow = [...state.userField[role], action.card];\n      let updatedUserField = { ...state.userField,\n        [role]: updatedUserRow\n      }; //Find the new total, including the added card\n\n      let newUserTotal = newTotalScore(updatedUserField);\n      return { ...state,\n        userField: updatedUserField,\n        hand: updatedUserHand,\n        userScore: newUserTotal\n      };\n      break;\n\n    case 'ENEMY_PLAY':\n      let chosenCard = state.enemyHand.slice(0, 1)[0];\n      let updatedEnemyHand = state.enemyHand.filter(card => card.id !== chosenCard.id);\n      let updatedEnemyRow = [...state.enemyField[chosenCard.role], chosenCard];\n      let updatedEnemyField = { ...state.enemyField,\n        [chosenCard.role]: updatedEnemyRow\n      };\n      let newEnemyTotal = newTotalScore(updatedEnemyField);\n      return { ...state,\n        enemyField: updatedEnemyField,\n        enemyHand: updatedEnemyHand,\n        enemyScore: newEnemyTotal\n      };\n      break;\n\n    case 'ENEMY_PASS':\n      return { ...state,\n        enemyPass: true,\n        userTurn: true\n      };\n      break;\n\n    case 'USER_PASS':\n      return { ...state,\n        userPass: true,\n        userTurn: false\n      };\n      break;\n\n    case 'ROUND_OVER':\n      if (state.userScore >= state.enemyScore) {\n        return { ...state,\n          enemyReactors: state.enemyReactors - 1\n        };\n      } else if (state.userScore < state.enemyScore) {\n        return { ...state,\n          userReactors: state.userReactors - 1\n        };\n      }\n\n      break;\n\n    case 'RESET_BOARD':\n      //This is super ugly but it works. We're setting the discard to everything in userField\n      //And then we're hardcoding in a clean new userField\n      let newUserDiscard = Object.values(state.userField).splice(0).flat();\n      let newEnemyDiscard = Object.values(state.enemyField).splice(0).flat();\n      let cleanUserField = {\n        userField: {\n          space: [],\n          ground: [],\n          foot: []\n        }\n      };\n      let cleanEnemyField = {\n        enemyField: {\n          space: [],\n          ground: [],\n          foot: []\n        }\n      };\n      return { ...state,\n        userField: cleanUserField.userField,\n        enemyField: cleanEnemyField.enemyField,\n        userPass: false,\n        enemyPass: false,\n        userDiscard: [...state.userDiscard, ...newUserDiscard],\n        enemyDiscard: [...state.enemyDiscard, ...newEnemyDiscard],\n        userScore: 0,\n        enemyScore: 0\n      };\n      break;\n\n    case 'GAME_OVER':\n      return { ...state,\n        userVictory: action.userVictory,\n        games: action.games,\n        userReactors: 2,\n        enemyReactors: 2,\n        gameOn: false,\n        userDiscard: [],\n        enemyDiscard: []\n      };\n      break;\n\n    default:\n      return state;\n  }\n};","map":{"version":3,"sources":["/Users/ben/flatiron/work/mod5/moon-gwent/frontend/src/store/reducers/index.js"],"names":["initialState","usernameInput","passwordInput","user","ownedCards","games","gameOn","drawHands","gameCards","enemyGameCards","hand","enemyHand","userDiscard","enemyDiscard","enemyField","space","ground","foot","userField","userScore","enemyScore","userTurn","userPass","enemyPass","userReactors","enemyReactors","userVictory","rowScore","array","score","i","length","strength","newTotalScore","field","total","Object","values","reduce","row","shuffle","currentIndex","temporaryValue","randomIndex","Math","floor","random","reducer","state","action","type","value","shuffledGameCards","shuffledEnemyGameCards","newGameCards","filter","card","includes","newEnemyGameCards","EnemyGameCards","role","updatedUserHand","id","updatedUserRow","updatedUserField","newUserTotal","chosenCard","slice","updatedEnemyHand","updatedEnemyRow","updatedEnemyField","newEnemyTotal","newUserDiscard","splice","flat","newEnemyDiscard","cleanUserField","cleanEnemyField"],"mappings":"AAAA,OAAO,MAAMA,YAAY,GAAG;AACxB;AACAC,EAAAA,aAAa,EAAE,EAFS;AAGxBC,EAAAA,aAAa,EAAE,EAHS;AAIxBC,EAAAA,IAAI,EAAE,EAJkB;AAKxBC,EAAAA,UAAU,EAAE,EALY;AAMxBC,EAAAA,KAAK,EAAE,EANiB;AAQxB;AACAC,EAAAA,MAAM,EAAE,KATgB;AAUxBC,EAAAA,SAAS,EAAE,KAVa;AAWxBC,EAAAA,SAAS,EAAE,EAXa;AAYxBC,EAAAA,cAAc,EAAE,EAZQ;AAaxBC,EAAAA,IAAI,EAAE,EAbkB;AAcxBC,EAAAA,SAAS,EAAE,EAda;AAexBC,EAAAA,WAAW,EAAE,EAfW;AAgBxBC,EAAAA,YAAY,EAAE,EAhBU;AAiBxBC,EAAAA,UAAU,EAAE;AACRC,IAAAA,KAAK,EAAE,EADC;AAERC,IAAAA,MAAM,EAAE,EAFA;AAGRC,IAAAA,IAAI,EAAE;AAHE,GAjBY;AAsBxBC,EAAAA,SAAS,EAAE;AACPH,IAAAA,KAAK,EAAE,EADA;AAEPC,IAAAA,MAAM,EAAE,EAFD;AAGPC,IAAAA,IAAI,EAAE;AAHC,GAtBa;AA4BxB;AACAE,EAAAA,SAAS,EAAE,CA7Ba;AA8BxBC,EAAAA,UAAU,EAAE,CA9BY;AAgCxB;AACAC,EAAAA,QAAQ,EAAE,IAjCc;AAkCxBC,EAAAA,QAAQ,EAAE,KAlCc;AAmCxBC,EAAAA,SAAS,EAAE,KAnCa;AAqCxB;AACAC,EAAAA,YAAY,EAAE,CAtCU;AAuCxBC,EAAAA,aAAa,EAAE,CAvCS;AAyCxBC,EAAAA,WAAW,EAAE;AAzCW,CAArB;;AA4CP,MAAMC,QAAQ,GAAIC,KAAD,IAAW;AACxB,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCD,IAAAA,KAAK,IAAID,KAAK,CAACE,CAAD,CAAL,CAASE,QAAlB;AACH;;AACD,SAAOH,KAAP;AACH,CAND;;AAQA,MAAMI,aAAa,GAAIC,KAAD,IAAW;AAC7B;AACA,MAAIC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAd,EAAqBI,MAArB,CAA4B,CAACH,KAAD,EAAQI,GAAR,KAAgBJ,KAAK,GAAIR,QAAQ,CAACY,GAAD,CAA7D,EAAqE,CAArE,CAAZ;AACA,SAAOJ,KAAP;AACH,CAJD;;AAMA,MAAMK,OAAO,GAAIZ,KAAD,IAAW;AACvB,MAAIa,YAAY,GAAGb,KAAK,CAACG,MAAzB;AAAA,MAAiCW,cAAjC;AAAA,MAAiDC,WAAjD,CADuB,CAGvB;;AACA,SAAO,MAAMF,YAAb,EAA2B;AAEvB;AACAE,IAAAA,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBL,YAA3B,CAAd;AACAA,IAAAA,YAAY,IAAI,CAAhB,CAJuB,CAMvB;;AACAC,IAAAA,cAAc,GAAGd,KAAK,CAACa,YAAD,CAAtB;AACAb,IAAAA,KAAK,CAACa,YAAD,CAAL,GAAsBb,KAAK,CAACe,WAAD,CAA3B;AACAf,IAAAA,KAAK,CAACe,WAAD,CAAL,GAAqBD,cAArB;AACH;;AAED,SAAOd,KAAP;AACH,CAjBD;;AAmBA,OAAO,MAAMmB,OAAO,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACtC,UAAQA,MAAM,CAACC,IAAf;AAEI,SAAK,uBAAL;AACI,aAAO,EAAE,GAAGF,KAAL;AAAY/C,QAAAA,aAAa,EAAEgD,MAAM,CAACE;AAAlC,OAAP;AACA;;AAEJ,SAAK,uBAAL;AACI,aAAO,EAAE,GAAGH,KAAL;AAAY9C,QAAAA,aAAa,EAAE+C,MAAM,CAACE;AAAlC,OAAP;AACA;;AAEJ,SAAK,UAAL;AACI,aAAO,EAAE,GAAGH,KAAL;AAAY7C,QAAAA,IAAI,EAAE8C,MAAM,CAAC9C,IAAzB;AAA+BC,QAAAA,UAAU,EAAE6C,MAAM,CAAC7C,UAAlD;AAA8DC,QAAAA,KAAK,EAAE4C,MAAM,CAAC5C,KAA5E;AAAmFC,QAAAA,MAAM,EAAE;AAA3F,OAAP;AACA;;AAEJ,SAAK,gBAAL;AACI;AACA,UAAI8C,iBAAiB,GAAGZ,OAAO,CAACQ,KAAK,CAAC5C,UAAP,CAA/B;AACA,UAAIiD,sBAAsB,GAAGb,OAAO,CAACQ,KAAK,CAAC5C,UAAP,CAApC;AACA,aAAO,EAAE,GAAG4C,KAAL;AAAYxC,QAAAA,SAAS,EAAE4C,iBAAvB;AAA0C3C,QAAAA,cAAc,EAAE4C,sBAA1D;AAAkF/C,QAAAA,MAAM,EAAE,IAA1F;AAAgGC,QAAAA,SAAS,EAAC;AAA1G,OAAP;AACA;;AAEJ,SAAK,WAAL;AACI;AACA;AACA,UAAI+C,YAAY,GAAGN,KAAK,CAACxC,SAAN,CAAgB+C,MAAhB,CAAuBC,IAAI,IAAI,CAAEP,MAAM,CAACvC,IAAP,CAAY+C,QAAZ,CAAqBD,IAArB,CAAjC,CAAnB;AACA,UAAIE,iBAAiB,GAAGV,KAAK,CAACW,cAAN,CAAqBJ,MAArB,CAA4BC,IAAI,IAAI,CAAEP,MAAM,CAACtC,SAAP,CAAiB8C,QAAjB,CAA0BD,IAA1B,CAAtC,CAAxB;AACA,aAAO,EAAE,GAAGR,KAAL;AACHtC,QAAAA,IAAI,EAAEuC,MAAM,CAACvC,IADV;AAEHC,QAAAA,SAAS,EAAEsC,MAAM,CAACtC,SAFf;AAGHJ,QAAAA,SAAS,EAAC;AAHP,OAAP;AAIA;;AAEJ,SAAK,WAAL;AACI;AACA,UAAIqD,IAAI,GAAGX,MAAM,CAACW,IAAlB,CAFJ,CAII;;AACA,UAAIC,eAAe,GAAGb,KAAK,CAACtC,IAAN,CAAW6C,MAAX,CAAkBC,IAAI,IAAIA,IAAI,CAACM,EAAL,KAAYb,MAAM,CAACO,IAAP,CAAYM,EAAlD,CAAtB,CALJ,CAOI;;AACA,UAAIC,cAAc,GAAG,CAAC,GAAGf,KAAK,CAAC9B,SAAN,CAAgB0C,IAAhB,CAAJ,EAA2BX,MAAM,CAACO,IAAlC,CAArB;AACA,UAAIQ,gBAAgB,GAAG,EAAE,GAAGhB,KAAK,CAAC9B,SAAX;AAAsB,SAAC0C,IAAD,GAAQG;AAA9B,OAAvB,CATJ,CAWI;;AACA,UAAIE,YAAY,GAAGhC,aAAa,CAAC+B,gBAAD,CAAhC;AACA,aAAO,EAAE,GAAGhB,KAAL;AAAY9B,QAAAA,SAAS,EAAE8C,gBAAvB;AAAyCtD,QAAAA,IAAI,EAAEmD,eAA/C;AAAgE1C,QAAAA,SAAS,EAAE8C;AAA3E,OAAP;AACA;;AAEJ,SAAK,YAAL;AAEI,UAAIC,UAAU,GAAGlB,KAAK,CAACrC,SAAN,CAAgBwD,KAAhB,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,CAAjB;AAEA,UAAIC,gBAAgB,GAAGpB,KAAK,CAACrC,SAAN,CAAgB4C,MAAhB,CAAuBC,IAAI,IAAIA,IAAI,CAACM,EAAL,KAAYI,UAAU,CAACJ,EAAtD,CAAvB;AAEA,UAAIO,eAAe,GAAG,CAAC,GAAGrB,KAAK,CAAClC,UAAN,CAAiBoD,UAAU,CAACN,IAA5B,CAAJ,EAAuCM,UAAvC,CAAtB;AACA,UAAII,iBAAiB,GAAG,EAAE,GAAGtB,KAAK,CAAClC,UAAX;AAAuB,SAACoD,UAAU,CAACN,IAAZ,GAAmBS;AAA1C,OAAxB;AAEA,UAAIE,aAAa,GAAGtC,aAAa,CAACqC,iBAAD,CAAjC;AACA,aAAO,EAAE,GAAGtB,KAAL;AAAYlC,QAAAA,UAAU,EAAEwD,iBAAxB;AAA2C3D,QAAAA,SAAS,EAAEyD,gBAAtD;AAAwEhD,QAAAA,UAAU,EAAEmD;AAApF,OAAP;AACA;;AAEJ,SAAK,YAAL;AACI,aAAO,EAAE,GAAGvB,KAAL;AAAYzB,QAAAA,SAAS,EAAE,IAAvB;AAA6BF,QAAAA,QAAQ,EAAE;AAAvC,OAAP;AACA;;AAEJ,SAAK,WAAL;AACI,aAAO,EAAE,GAAG2B,KAAL;AAAY1B,QAAAA,QAAQ,EAAE,IAAtB;AAA4BD,QAAAA,QAAQ,EAAE;AAAtC,OAAP;AACA;;AAEJ,SAAK,YAAL;AACI,UAAI2B,KAAK,CAAC7B,SAAN,IAAmB6B,KAAK,CAAC5B,UAA7B,EAAyC;AACrC,eAAO,EAAE,GAAG4B,KAAL;AAAYvB,UAAAA,aAAa,EAAGuB,KAAK,CAACvB,aAAN,GAAsB;AAAlD,SAAP;AACH,OAFD,MAGK,IAAIuB,KAAK,CAAC7B,SAAN,GAAkB6B,KAAK,CAAC5B,UAA5B,EAAwC;AACzC,eAAO,EAAE,GAAG4B,KAAL;AAAYxB,UAAAA,YAAY,EAAGwB,KAAK,CAACxB,YAAN,GAAqB;AAAhD,SAAP;AACH;;AACD;;AAEJ,SAAK,aAAL;AACI;AACA;AACA,UAAIgD,cAAc,GAAGpC,MAAM,CAACC,MAAP,CAAcW,KAAK,CAAC9B,SAApB,EAA+BuD,MAA/B,CAAsC,CAAtC,EAAyCC,IAAzC,EAArB;AACA,UAAIC,eAAe,GAAGvC,MAAM,CAACC,MAAP,CAAcW,KAAK,CAAClC,UAApB,EAAgC2D,MAAhC,CAAuC,CAAvC,EAA0CC,IAA1C,EAAtB;AACA,UAAIE,cAAc,GAAG;AACjB1D,QAAAA,SAAS,EAAE;AACPH,UAAAA,KAAK,EAAE,EADA;AAEPC,UAAAA,MAAM,EAAE,EAFD;AAGPC,UAAAA,IAAI,EAAE;AAHC;AADM,OAArB;AAOA,UAAI4D,eAAe,GAAG;AAClB/D,QAAAA,UAAU,EAAE;AACRC,UAAAA,KAAK,EAAE,EADC;AAERC,UAAAA,MAAM,EAAE,EAFA;AAGRC,UAAAA,IAAI,EAAE;AAHE;AADM,OAAtB;AAOA,aAAO,EACH,GAAG+B,KADA;AAEH9B,QAAAA,SAAS,EAAE0D,cAAc,CAAC1D,SAFvB;AAGHJ,QAAAA,UAAU,EAAE+D,eAAe,CAAC/D,UAHzB;AAIHQ,QAAAA,QAAQ,EAAE,KAJP;AAKHC,QAAAA,SAAS,EAAE,KALR;AAMHX,QAAAA,WAAW,EAAE,CAAC,GAAGoC,KAAK,CAACpC,WAAV,EAAuB,GAAG4D,cAA1B,CANV;AAOH3D,QAAAA,YAAY,EAAE,CAAC,GAAGmC,KAAK,CAACnC,YAAV,EAAwB,GAAG8D,eAA3B,CAPX;AAQHxD,QAAAA,SAAS,EAAE,CARR;AASHC,QAAAA,UAAU,EAAE;AATT,OAAP;AAWA;;AAEJ,SAAK,WAAL;AACI,aAAO,EACH,GAAG4B,KADA;AAEHtB,QAAAA,WAAW,EAAEuB,MAAM,CAACvB,WAFjB;AAGHrB,QAAAA,KAAK,EAAE4C,MAAM,CAAC5C,KAHX;AAIHmB,QAAAA,YAAY,EAAE,CAJX;AAKHC,QAAAA,aAAa,EAAE,CALZ;AAMHnB,QAAAA,MAAM,EAAE,KANL;AAOHM,QAAAA,WAAW,EAAE,EAPV;AAQHC,QAAAA,YAAY,EAAE;AARX,OAAP;AAUA;;AAEJ;AACI,aAAOmC,KAAP;AA5HR;AA8HH,CA/HM","sourcesContent":["export const initialState = {\n    //login\n    usernameInput: '',\n    passwordInput: '',\n    user: {},\n    ownedCards: [],\n    games: [],\n\n    //gameboard\n    gameOn: false,\n    drawHands: false,\n    gameCards: [],\n    enemyGameCards: [],\n    hand: [],\n    enemyHand: [],\n    userDiscard: [],\n    enemyDiscard: [],\n    enemyField: {\n        space: [],\n        ground: [],\n        foot: []\n    },\n    userField: {\n        space: [],\n        ground: [],\n        foot: []\n    },\n\n    //scores \n    userScore: 0,\n    enemyScore: 0,\n\n    //passing\n    userTurn: true,\n    userPass: false,\n    enemyPass: false,\n\n    //reactors \n    userReactors: 2,\n    enemyReactors: 2,\n\n    userVictory: null\n}\n\nconst rowScore = (array) => {\n    let score = 0\n    for (let i = 0; i < array.length; i++) {\n        score += array[i].strength\n    }\n    return score\n}\n\nconst newTotalScore = (field) => {\n    //we iterate through the field values (rows), and get the total of each rowScore\n    let total = Object.values(field).reduce((total, row) => total + (rowScore(row)), 0)\n    return total\n}\n\nconst shuffle = (array) => {\n    var currentIndex = array.length, temporaryValue, randomIndex;\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n\n        // And swap it with the current element.\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n    }\n\n    return array;\n}\n\nexport const reducer = (state, action) => {\n    switch (action.type) {\n\n        case 'CHANGE_USERNAME_INPUT':\n            return { ...state, usernameInput: action.value }\n            break;\n\n        case 'CHANGE_PASSWORD_INPUT':\n            return { ...state, passwordInput: action.value }\n            break;\n\n        case 'SET_USER':\n            return { ...state, user: action.user, ownedCards: action.ownedCards, games: action.games, gameOn: false }\n            break;\n\n        case 'SET_GAME_CARDS':\n            //TODO -> Gets sent a list of chosen cards to set as gameCards from the selection screen\n            let shuffledGameCards = shuffle(state.ownedCards)\n            let shuffledEnemyGameCards = shuffle(state.ownedCards)\n            return { ...state, gameCards: shuffledGameCards, enemyGameCards: shuffledEnemyGameCards, gameOn: true, drawHands:true }\n            break;\n\n        case 'SET_HANDS':\n            //Separate from game cards because hand is drawn in the battlefield, not the selection screen\n            //TODO -> Hand is drawn from gameCards\n            let newGameCards = state.gameCards.filter(card => !(action.hand.includes(card)))\n            let newEnemyGameCards = state.EnemyGameCards.filter(card => !(action.enemyHand.includes(card)))\n            return { ...state, \n                hand: action.hand, \n                enemyHand: action.enemyHand, \n                drawHands:false}\n            break;\n\n        case 'PLAY_CARD':\n            //Possible change --> send over something to indicate whether it's the enemy or user \n            let role = action.role\n\n            //Remove the card from hand\n            let updatedUserHand = state.hand.filter(card => card.id !== action.card.id)\n\n            //Update the row, then update the field with that row \n            let updatedUserRow = [...state.userField[role], action.card]\n            let updatedUserField = { ...state.userField, [role]: updatedUserRow }\n\n            //Find the new total, including the added card\n            let newUserTotal = newTotalScore(updatedUserField)\n            return { ...state, userField: updatedUserField, hand: updatedUserHand, userScore: newUserTotal }\n            break;\n\n        case 'ENEMY_PLAY':\n\n            let chosenCard = state.enemyHand.slice(0, 1)[0]\n\n            let updatedEnemyHand = state.enemyHand.filter(card => card.id !== chosenCard.id)\n\n            let updatedEnemyRow = [...state.enemyField[chosenCard.role], chosenCard]\n            let updatedEnemyField = { ...state.enemyField, [chosenCard.role]: updatedEnemyRow }\n\n            let newEnemyTotal = newTotalScore(updatedEnemyField)\n            return { ...state, enemyField: updatedEnemyField, enemyHand: updatedEnemyHand, enemyScore: newEnemyTotal }\n            break;\n\n        case 'ENEMY_PASS':\n            return { ...state, enemyPass: true, userTurn: true }\n            break;\n\n        case 'USER_PASS':\n            return { ...state, userPass: true, userTurn: false }\n            break;\n\n        case 'ROUND_OVER':\n            if (state.userScore >= state.enemyScore) {\n                return { ...state, enemyReactors: (state.enemyReactors - 1) }\n            }\n            else if (state.userScore < state.enemyScore) {\n                return { ...state, userReactors: (state.userReactors - 1) }\n            }\n            break;\n\n        case 'RESET_BOARD':\n            //This is super ugly but it works. We're setting the discard to everything in userField\n            //And then we're hardcoding in a clean new userField\n            let newUserDiscard = Object.values(state.userField).splice(0).flat();\n            let newEnemyDiscard = Object.values(state.enemyField).splice(0).flat();\n            let cleanUserField = {\n                userField: {\n                    space: [],\n                    ground: [],\n                    foot: []\n                }\n            }\n            let cleanEnemyField = {\n                enemyField: {\n                    space: [],\n                    ground: [],\n                    foot: []\n                }\n            }\n            return {\n                ...state,\n                userField: cleanUserField.userField,\n                enemyField: cleanEnemyField.enemyField,\n                userPass: false,\n                enemyPass: false,\n                userDiscard: [...state.userDiscard, ...newUserDiscard],\n                enemyDiscard: [...state.enemyDiscard, ...newEnemyDiscard],\n                userScore: 0,\n                enemyScore: 0\n            }\n            break;\n\n        case 'GAME_OVER':\n            return {\n                ...state,\n                userVictory: action.userVictory,\n                games: action.games,\n                userReactors: 2,\n                enemyReactors: 2,\n                gameOn: false,\n                userDiscard: [],\n                enemyDiscard: []\n            }\n            break;\n\n        default:\n            return state\n    }\n}"]},"metadata":{},"sourceType":"module"}